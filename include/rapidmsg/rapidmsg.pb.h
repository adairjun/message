// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rapidmsg.proto

#ifndef PROTOBUF_rapidmsg_2eproto__INCLUDED
#define PROTOBUF_rapidmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rapidmsg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_rapidmsg_2eproto();
void protobuf_AssignDesc_rapidmsg_2eproto();
void protobuf_ShutdownFile_rapidmsg_2eproto();

class Body;
class Head;
class InternalHead;
class IpAddress;
class IpPortPair;
class RMessage;
class ResponseCode;
class SimpleResponse;

enum MessageType {
  SIMPLE_RESPONSE = 10
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = SIMPLE_RESPONSE;
const MessageType MessageType_MAX = SIMPLE_RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class RMessage : public ::google::protobuf::Message {
 public:
  RMessage();
  virtual ~RMessage();

  RMessage(const RMessage& from);

  inline RMessage& operator=(const RMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RMessage& default_instance();

  void Swap(RMessage* other);

  // implements Message ----------------------------------------------

  inline RMessage* New() const { return New(NULL); }

  RMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RMessage& from);
  void MergeFrom(const RMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rapidmsg.Head head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::rapidmsg::Head& head() const;
  ::rapidmsg::Head* mutable_head();
  ::rapidmsg::Head* release_head();
  void set_allocated_head(::rapidmsg::Head* head);

  // required .rapidmsg.Body body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::rapidmsg::Body& body() const;
  ::rapidmsg::Body* mutable_body();
  ::rapidmsg::Body* release_body();
  void set_allocated_body(::rapidmsg::Body* body);

  // @@protoc_insertion_point(class_scope:rapidmsg.RMessage)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rapidmsg::Head* head_;
  ::rapidmsg::Body* body_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static RMessage* default_instance_;
};
// -------------------------------------------------------------------

class Head : public ::google::protobuf::Message {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();

  void Swap(Head* other);

  // implements Message ----------------------------------------------

  inline Head* New() const { return New(NULL); }

  Head* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Head* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string session_no = 1;
  bool has_session_no() const;
  void clear_session_no();
  static const int kSessionNoFieldNumber = 1;
  const ::std::string& session_no() const;
  void set_session_no(const ::std::string& value);
  void set_session_no(const char* value);
  void set_session_no(const char* value, size_t size);
  ::std::string* mutable_session_no();
  ::std::string* release_session_no();
  void set_allocated_session_no(::std::string* session_no);

  // required uint32 message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  ::google::protobuf::uint32 message_type() const;
  void set_message_type(::google::protobuf::uint32 value);

  // optional string client_ip = 3;
  bool has_client_ip() const;
  void clear_client_ip();
  static const int kClientIpFieldNumber = 3;
  const ::std::string& client_ip() const;
  void set_client_ip(const ::std::string& value);
  void set_client_ip(const char* value);
  void set_client_ip(const char* value, size_t size);
  ::std::string* mutable_client_ip();
  ::std::string* release_client_ip();
  void set_allocated_client_ip(::std::string* client_ip);

  // optional uint32 client_port = 4;
  bool has_client_port() const;
  void clear_client_port();
  static const int kClientPortFieldNumber = 4;
  ::google::protobuf::uint32 client_port() const;
  void set_client_port(::google::protobuf::uint32 value);

  // optional string target_ip = 5;
  bool has_target_ip() const;
  void clear_target_ip();
  static const int kTargetIpFieldNumber = 5;
  const ::std::string& target_ip() const;
  void set_target_ip(const ::std::string& value);
  void set_target_ip(const char* value);
  void set_target_ip(const char* value, size_t size);
  ::std::string* mutable_target_ip();
  ::std::string* release_target_ip();
  void set_allocated_target_ip(::std::string* target_ip);

  // optional uint32 target_port = 6;
  bool has_target_port() const;
  void clear_target_port();
  static const int kTargetPortFieldNumber = 6;
  ::google::protobuf::uint32 target_port() const;
  void set_target_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.Head)
 private:
  inline void set_has_session_no();
  inline void clear_has_session_no();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_client_port();
  inline void clear_has_client_port();
  inline void set_has_target_ip();
  inline void clear_has_target_ip();
  inline void set_has_target_port();
  inline void clear_has_target_port();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_no_;
  ::google::protobuf::internal::ArenaStringPtr client_ip_;
  ::google::protobuf::uint32 message_type_;
  ::google::protobuf::uint32 client_port_;
  ::google::protobuf::internal::ArenaStringPtr target_ip_;
  ::google::protobuf::uint32 target_port_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class Body : public ::google::protobuf::Message {
 public:
  Body();
  virtual ~Body();

  Body(const Body& from);

  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Body& default_instance();

  void Swap(Body* other);

  // implements Message ----------------------------------------------

  inline Body* New() const { return New(NULL); }

  Body* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Body& from);
  void MergeFrom(const Body& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Body* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rapidmsg.SimpleResponse simple_response = 1;
  bool has_simple_response() const;
  void clear_simple_response();
  static const int kSimpleResponseFieldNumber = 1;
  const ::rapidmsg::SimpleResponse& simple_response() const;
  ::rapidmsg::SimpleResponse* mutable_simple_response();
  ::rapidmsg::SimpleResponse* release_simple_response();
  void set_allocated_simple_response(::rapidmsg::SimpleResponse* simple_response);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Body)
  // @@protoc_insertion_point(class_scope:rapidmsg.Body)
 private:
  inline void set_has_simple_response();
  inline void clear_has_simple_response();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rapidmsg::SimpleResponse* simple_response_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static Body* default_instance_;
};
// -------------------------------------------------------------------

class IpPortPair : public ::google::protobuf::Message {
 public:
  IpPortPair();
  virtual ~IpPortPair();

  IpPortPair(const IpPortPair& from);

  inline IpPortPair& operator=(const IpPortPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpPortPair& default_instance();

  void Swap(IpPortPair* other);

  // implements Message ----------------------------------------------

  inline IpPortPair* New() const { return New(NULL); }

  IpPortPair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpPortPair& from);
  void MergeFrom(const IpPortPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpPortPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  ::google::protobuf::uint32 ip() const;
  void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.IpPortPair)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static IpPortPair* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCode : public ::google::protobuf::Message {
 public:
  ResponseCode();
  virtual ~ResponseCode();

  ResponseCode(const ResponseCode& from);

  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCode& default_instance();

  void Swap(ResponseCode* other);

  // implements Message ----------------------------------------------

  inline ResponseCode* New() const { return New(NULL); }

  ResponseCode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseCode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 retcode = 1;
  bool has_retcode() const;
  void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  ::google::protobuf::int32 retcode() const;
  void set_retcode(::google::protobuf::int32 value);

  // optional string error_message = 2;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:rapidmsg.ResponseCode)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::int32 retcode_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static ResponseCode* default_instance_;
};
// -------------------------------------------------------------------

class IpAddress : public ::google::protobuf::Message {
 public:
  IpAddress();
  virtual ~IpAddress();

  IpAddress(const IpAddress& from);

  inline IpAddress& operator=(const IpAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpAddress& default_instance();

  void Swap(IpAddress* other);

  // implements Message ----------------------------------------------

  inline IpAddress* New() const { return New(NULL); }

  IpAddress* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpAddress& from);
  void MergeFrom(const IpAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.IpAddress)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_type();
  inline void clear_has_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 type_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static IpAddress* default_instance_;
};
// -------------------------------------------------------------------

class SimpleResponse : public ::google::protobuf::Message {
 public:
  SimpleResponse();
  virtual ~SimpleResponse();

  SimpleResponse(const SimpleResponse& from);

  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleResponse& default_instance();

  void Swap(SimpleResponse* other);

  // implements Message ----------------------------------------------

  inline SimpleResponse* New() const { return New(NULL); }

  SimpleResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleResponse& from);
  void MergeFrom(const SimpleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rapidmsg.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;
  const ::rapidmsg::ResponseCode& rc() const;
  ::rapidmsg::ResponseCode* mutable_rc();
  ::rapidmsg::ResponseCode* release_rc();
  void set_allocated_rc(::rapidmsg::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:rapidmsg.SimpleResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rapidmsg::ResponseCode* rc_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static SimpleResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalHead : public ::google::protobuf::Message {
 public:
  InternalHead();
  virtual ~InternalHead();

  InternalHead(const InternalHead& from);

  inline InternalHead& operator=(const InternalHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHead& default_instance();

  void Swap(InternalHead* other);

  // implements Message ----------------------------------------------

  inline InternalHead* New() const { return New(NULL); }

  InternalHead* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHead& from);
  void MergeFrom(const InternalHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternalHead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fd = 10;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 10;
  ::google::protobuf::int32 fd() const;
  void set_fd(::google::protobuf::int32 value);

  // required uint32 peer_addr = 20;
  bool has_peer_addr() const;
  void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 20;
  ::google::protobuf::uint32 peer_addr() const;
  void set_peer_addr(::google::protobuf::uint32 value);

  // required int32 peer_port = 30;
  bool has_peer_port() const;
  void clear_peer_port();
  static const int kPeerPortFieldNumber = 30;
  ::google::protobuf::int32 peer_port() const;
  void set_peer_port(::google::protobuf::int32 value);

  // required uint32 sock_addr = 40;
  bool has_sock_addr() const;
  void clear_sock_addr();
  static const int kSockAddrFieldNumber = 40;
  ::google::protobuf::uint32 sock_addr() const;
  void set_sock_addr(::google::protobuf::uint32 value);

  // required int32 sock_port = 50;
  bool has_sock_port() const;
  void clear_sock_port();
  static const int kSockPortFieldNumber = 50;
  ::google::protobuf::int32 sock_port() const;
  void set_sock_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.InternalHead)
 private:
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_peer_addr();
  inline void clear_has_peer_addr();
  inline void set_has_peer_port();
  inline void clear_has_peer_port();
  inline void set_has_sock_addr();
  inline void clear_has_sock_addr();
  inline void set_has_sock_port();
  inline void clear_has_sock_port();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::uint32 peer_addr_;
  ::google::protobuf::int32 peer_port_;
  ::google::protobuf::uint32 sock_addr_;
  ::google::protobuf::int32 sock_port_;
  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static InternalHead* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RMessage

// required .rapidmsg.Head head = 1;
inline bool RMessage::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RMessage::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RMessage::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RMessage::clear_head() {
  if (head_ != NULL) head_->::rapidmsg::Head::Clear();
  clear_has_head();
}
inline const ::rapidmsg::Head& RMessage::head() const {
  // @@protoc_insertion_point(field_get:rapidmsg.RMessage.head)
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::rapidmsg::Head* RMessage::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::rapidmsg::Head;
  }
  // @@protoc_insertion_point(field_mutable:rapidmsg.RMessage.head)
  return head_;
}
inline ::rapidmsg::Head* RMessage::release_head() {
  clear_has_head();
  ::rapidmsg::Head* temp = head_;
  head_ = NULL;
  return temp;
}
inline void RMessage::set_allocated_head(::rapidmsg::Head* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.RMessage.head)
}

// required .rapidmsg.Body body = 2;
inline bool RMessage::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RMessage::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RMessage::clear_body() {
  if (body_ != NULL) body_->::rapidmsg::Body::Clear();
  clear_has_body();
}
inline const ::rapidmsg::Body& RMessage::body() const {
  // @@protoc_insertion_point(field_get:rapidmsg.RMessage.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::rapidmsg::Body* RMessage::mutable_body() {
  set_has_body();
  if (body_ == NULL) {
    body_ = new ::rapidmsg::Body;
  }
  // @@protoc_insertion_point(field_mutable:rapidmsg.RMessage.body)
  return body_;
}
inline ::rapidmsg::Body* RMessage::release_body() {
  clear_has_body();
  ::rapidmsg::Body* temp = body_;
  body_ = NULL;
  return temp;
}
inline void RMessage::set_allocated_body(::rapidmsg::Body* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.RMessage.body)
}

// -------------------------------------------------------------------

// Head

// required string session_no = 1;
inline bool Head::has_session_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_session_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Head::clear_has_session_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Head::clear_session_no() {
  session_no_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_no();
}
inline const ::std::string& Head::session_no() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Head.session_no)
  return session_no_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_session_no(const ::std::string& value) {
  set_has_session_no();
  session_no_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rapidmsg.Head.session_no)
}
inline void Head::set_session_no(const char* value) {
  set_has_session_no();
  session_no_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rapidmsg.Head.session_no)
}
inline void Head::set_session_no(const char* value, size_t size) {
  set_has_session_no();
  session_no_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rapidmsg.Head.session_no)
}
inline ::std::string* Head::mutable_session_no() {
  set_has_session_no();
  // @@protoc_insertion_point(field_mutable:rapidmsg.Head.session_no)
  return session_no_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Head::release_session_no() {
  clear_has_session_no();
  return session_no_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_allocated_session_no(::std::string* session_no) {
  if (session_no != NULL) {
    set_has_session_no();
  } else {
    clear_has_session_no();
  }
  session_no_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_no);
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.Head.session_no)
}

// required uint32 message_type = 2;
inline bool Head::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Head::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Head::clear_message_type() {
  message_type_ = 0u;
  clear_has_message_type();
}
inline ::google::protobuf::uint32 Head::message_type() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Head.message_type)
  return message_type_;
}
inline void Head::set_message_type(::google::protobuf::uint32 value) {
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.Head.message_type)
}

// optional string client_ip = 3;
inline bool Head::has_client_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_client_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Head::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Head::clear_client_ip() {
  client_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_ip();
}
inline const ::std::string& Head::client_ip() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Head.client_ip)
  return client_ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_client_ip(const ::std::string& value) {
  set_has_client_ip();
  client_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rapidmsg.Head.client_ip)
}
inline void Head::set_client_ip(const char* value) {
  set_has_client_ip();
  client_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rapidmsg.Head.client_ip)
}
inline void Head::set_client_ip(const char* value, size_t size) {
  set_has_client_ip();
  client_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rapidmsg.Head.client_ip)
}
inline ::std::string* Head::mutable_client_ip() {
  set_has_client_ip();
  // @@protoc_insertion_point(field_mutable:rapidmsg.Head.client_ip)
  return client_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Head::release_client_ip() {
  clear_has_client_ip();
  return client_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_allocated_client_ip(::std::string* client_ip) {
  if (client_ip != NULL) {
    set_has_client_ip();
  } else {
    clear_has_client_ip();
  }
  client_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_ip);
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.Head.client_ip)
}

// optional uint32 client_port = 4;
inline bool Head::has_client_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Head::set_has_client_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Head::clear_has_client_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Head::clear_client_port() {
  client_port_ = 0u;
  clear_has_client_port();
}
inline ::google::protobuf::uint32 Head::client_port() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Head.client_port)
  return client_port_;
}
inline void Head::set_client_port(::google::protobuf::uint32 value) {
  set_has_client_port();
  client_port_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.Head.client_port)
}

// optional string target_ip = 5;
inline bool Head::has_target_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Head::set_has_target_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Head::clear_has_target_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Head::clear_target_ip() {
  target_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_ip();
}
inline const ::std::string& Head::target_ip() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Head.target_ip)
  return target_ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_target_ip(const ::std::string& value) {
  set_has_target_ip();
  target_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rapidmsg.Head.target_ip)
}
inline void Head::set_target_ip(const char* value) {
  set_has_target_ip();
  target_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rapidmsg.Head.target_ip)
}
inline void Head::set_target_ip(const char* value, size_t size) {
  set_has_target_ip();
  target_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rapidmsg.Head.target_ip)
}
inline ::std::string* Head::mutable_target_ip() {
  set_has_target_ip();
  // @@protoc_insertion_point(field_mutable:rapidmsg.Head.target_ip)
  return target_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Head::release_target_ip() {
  clear_has_target_ip();
  return target_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_allocated_target_ip(::std::string* target_ip) {
  if (target_ip != NULL) {
    set_has_target_ip();
  } else {
    clear_has_target_ip();
  }
  target_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_ip);
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.Head.target_ip)
}

// optional uint32 target_port = 6;
inline bool Head::has_target_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Head::set_has_target_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Head::clear_has_target_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Head::clear_target_port() {
  target_port_ = 0u;
  clear_has_target_port();
}
inline ::google::protobuf::uint32 Head::target_port() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Head.target_port)
  return target_port_;
}
inline void Head::set_target_port(::google::protobuf::uint32 value) {
  set_has_target_port();
  target_port_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.Head.target_port)
}

// -------------------------------------------------------------------

// Body

// optional .rapidmsg.SimpleResponse simple_response = 1;
inline bool Body::has_simple_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Body::set_has_simple_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Body::clear_has_simple_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Body::clear_simple_response() {
  if (simple_response_ != NULL) simple_response_->::rapidmsg::SimpleResponse::Clear();
  clear_has_simple_response();
}
inline const ::rapidmsg::SimpleResponse& Body::simple_response() const {
  // @@protoc_insertion_point(field_get:rapidmsg.Body.simple_response)
  return simple_response_ != NULL ? *simple_response_ : *default_instance_->simple_response_;
}
inline ::rapidmsg::SimpleResponse* Body::mutable_simple_response() {
  set_has_simple_response();
  if (simple_response_ == NULL) {
    simple_response_ = new ::rapidmsg::SimpleResponse;
  }
  // @@protoc_insertion_point(field_mutable:rapidmsg.Body.simple_response)
  return simple_response_;
}
inline ::rapidmsg::SimpleResponse* Body::release_simple_response() {
  clear_has_simple_response();
  ::rapidmsg::SimpleResponse* temp = simple_response_;
  simple_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_simple_response(::rapidmsg::SimpleResponse* simple_response) {
  delete simple_response_;
  simple_response_ = simple_response;
  if (simple_response) {
    set_has_simple_response();
  } else {
    clear_has_simple_response();
  }
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.Body.simple_response)
}

// -------------------------------------------------------------------

// IpPortPair

// required uint32 ip = 1;
inline bool IpPortPair::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpPortPair::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpPortPair::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpPortPair::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 IpPortPair::ip() const {
  // @@protoc_insertion_point(field_get:rapidmsg.IpPortPair.ip)
  return ip_;
}
inline void IpPortPair::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.IpPortPair.ip)
}

// required uint32 port = 2;
inline bool IpPortPair::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpPortPair::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpPortPair::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpPortPair::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpPortPair::port() const {
  // @@protoc_insertion_point(field_get:rapidmsg.IpPortPair.port)
  return port_;
}
inline void IpPortPair::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.IpPortPair.port)
}

// -------------------------------------------------------------------

// ResponseCode

// required int32 retcode = 1;
inline bool ResponseCode::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCode::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCode::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 ResponseCode::retcode() const {
  // @@protoc_insertion_point(field_get:rapidmsg.ResponseCode.retcode)
  return retcode_;
}
inline void ResponseCode::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.ResponseCode.retcode)
}

// optional string error_message = 2;
inline bool ResponseCode::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCode::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCode::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCode::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& ResponseCode::error_message() const {
  // @@protoc_insertion_point(field_get:rapidmsg.ResponseCode.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCode::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rapidmsg.ResponseCode.error_message)
}
inline void ResponseCode::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rapidmsg.ResponseCode.error_message)
}
inline void ResponseCode::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rapidmsg.ResponseCode.error_message)
}
inline ::std::string* ResponseCode::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:rapidmsg.ResponseCode.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCode::release_error_message() {
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCode::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.ResponseCode.error_message)
}

// -------------------------------------------------------------------

// IpAddress

// required string ip = 1;
inline bool IpAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddress::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& IpAddress::ip() const {
  // @@protoc_insertion_point(field_get:rapidmsg.IpAddress.ip)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IpAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rapidmsg.IpAddress.ip)
}
inline void IpAddress::set_ip(const char* value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rapidmsg.IpAddress.ip)
}
inline void IpAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rapidmsg.IpAddress.ip)
}
inline ::std::string* IpAddress::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:rapidmsg.IpAddress.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IpAddress::release_ip() {
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IpAddress::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.IpAddress.ip)
}

// required uint32 type = 2;
inline bool IpAddress::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddress::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddress::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddress::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 IpAddress::type() const {
  // @@protoc_insertion_point(field_get:rapidmsg.IpAddress.type)
  return type_;
}
inline void IpAddress::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.IpAddress.type)
}

// -------------------------------------------------------------------

// SimpleResponse

// required .rapidmsg.ResponseCode rc = 1;
inline bool SimpleResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleResponse::clear_rc() {
  if (rc_ != NULL) rc_->::rapidmsg::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::rapidmsg::ResponseCode& SimpleResponse::rc() const {
  // @@protoc_insertion_point(field_get:rapidmsg.SimpleResponse.rc)
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::rapidmsg::ResponseCode* SimpleResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    rc_ = new ::rapidmsg::ResponseCode;
  }
  // @@protoc_insertion_point(field_mutable:rapidmsg.SimpleResponse.rc)
  return rc_;
}
inline ::rapidmsg::ResponseCode* SimpleResponse::release_rc() {
  clear_has_rc();
  ::rapidmsg::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void SimpleResponse::set_allocated_rc(::rapidmsg::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
  // @@protoc_insertion_point(field_set_allocated:rapidmsg.SimpleResponse.rc)
}

// -------------------------------------------------------------------

// InternalHead

// required int32 fd = 10;
inline bool InternalHead::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHead::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHead::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHead::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 InternalHead::fd() const {
  // @@protoc_insertion_point(field_get:rapidmsg.InternalHead.fd)
  return fd_;
}
inline void InternalHead::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.InternalHead.fd)
}

// required uint32 peer_addr = 20;
inline bool InternalHead::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalHead::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalHead::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalHead::clear_peer_addr() {
  peer_addr_ = 0u;
  clear_has_peer_addr();
}
inline ::google::protobuf::uint32 InternalHead::peer_addr() const {
  // @@protoc_insertion_point(field_get:rapidmsg.InternalHead.peer_addr)
  return peer_addr_;
}
inline void InternalHead::set_peer_addr(::google::protobuf::uint32 value) {
  set_has_peer_addr();
  peer_addr_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.InternalHead.peer_addr)
}

// required int32 peer_port = 30;
inline bool InternalHead::has_peer_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalHead::set_has_peer_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalHead::clear_has_peer_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalHead::clear_peer_port() {
  peer_port_ = 0;
  clear_has_peer_port();
}
inline ::google::protobuf::int32 InternalHead::peer_port() const {
  // @@protoc_insertion_point(field_get:rapidmsg.InternalHead.peer_port)
  return peer_port_;
}
inline void InternalHead::set_peer_port(::google::protobuf::int32 value) {
  set_has_peer_port();
  peer_port_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.InternalHead.peer_port)
}

// required uint32 sock_addr = 40;
inline bool InternalHead::has_sock_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalHead::set_has_sock_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalHead::clear_has_sock_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalHead::clear_sock_addr() {
  sock_addr_ = 0u;
  clear_has_sock_addr();
}
inline ::google::protobuf::uint32 InternalHead::sock_addr() const {
  // @@protoc_insertion_point(field_get:rapidmsg.InternalHead.sock_addr)
  return sock_addr_;
}
inline void InternalHead::set_sock_addr(::google::protobuf::uint32 value) {
  set_has_sock_addr();
  sock_addr_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.InternalHead.sock_addr)
}

// required int32 sock_port = 50;
inline bool InternalHead::has_sock_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalHead::set_has_sock_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalHead::clear_has_sock_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalHead::clear_sock_port() {
  sock_port_ = 0;
  clear_has_sock_port();
}
inline ::google::protobuf::int32 InternalHead::sock_port() const {
  // @@protoc_insertion_point(field_get:rapidmsg.InternalHead.sock_port)
  return sock_port_;
}
inline void InternalHead::set_sock_port(::google::protobuf::int32 value) {
  set_has_sock_port();
  sock_port_ = value;
  // @@protoc_insertion_point(field_set:rapidmsg.InternalHead.sock_port)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rapidmsg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::rapidmsg::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rapidmsg::MessageType>() {
  return ::rapidmsg::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rapidmsg_2eproto__INCLUDED
