// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rapidmsg.proto

#ifndef PROTOBUF_rapidmsg_2eproto__INCLUDED
#define PROTOBUF_rapidmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rapidmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rapidmsg_2eproto();
void protobuf_AssignDesc_rapidmsg_2eproto();
void protobuf_ShutdownFile_rapidmsg_2eproto();

class RMessage;
class Head;
class Body;
class IpPortPair;
class ResponseCode;
class IpAddress;
class SimpleResponse;
class InternalHead;

enum MessageType {
  SIMPLE_RESPONSE = 10
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = SIMPLE_RESPONSE;
const MessageType MessageType_MAX = SIMPLE_RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class RMessage : public ::google::protobuf::Message {
 public:
  RMessage();
  virtual ~RMessage();

  RMessage(const RMessage& from);

  inline RMessage& operator=(const RMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RMessage& default_instance();

  void Swap(RMessage* other);

  // implements Message ----------------------------------------------

  RMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RMessage& from);
  void MergeFrom(const RMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rapidmsg.Head head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::rapidmsg::Head& head() const;
  inline ::rapidmsg::Head* mutable_head();
  inline ::rapidmsg::Head* release_head();
  inline void set_allocated_head(::rapidmsg::Head* head);

  // required .rapidmsg.Body body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::rapidmsg::Body& body() const;
  inline ::rapidmsg::Body* mutable_body();
  inline ::rapidmsg::Body* release_body();
  inline void set_allocated_body(::rapidmsg::Body* body);

  // @@protoc_insertion_point(class_scope:rapidmsg.RMessage)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rapidmsg::Head* head_;
  ::rapidmsg::Body* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static RMessage* default_instance_;
};
// -------------------------------------------------------------------

class Head : public ::google::protobuf::Message {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();

  void Swap(Head* other);

  // implements Message ----------------------------------------------

  Head* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string session_no = 1;
  inline bool has_session_no() const;
  inline void clear_session_no();
  static const int kSessionNoFieldNumber = 1;
  inline const ::std::string& session_no() const;
  inline void set_session_no(const ::std::string& value);
  inline void set_session_no(const char* value);
  inline void set_session_no(const char* value, size_t size);
  inline ::std::string* mutable_session_no();
  inline ::std::string* release_session_no();
  inline void set_allocated_session_no(::std::string* session_no);

  // required uint32 message_type = 2;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 message_type() const;
  inline void set_message_type(::google::protobuf::uint32 value);

  // optional string client_ip = 3;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 3;
  inline const ::std::string& client_ip() const;
  inline void set_client_ip(const ::std::string& value);
  inline void set_client_ip(const char* value);
  inline void set_client_ip(const char* value, size_t size);
  inline ::std::string* mutable_client_ip();
  inline ::std::string* release_client_ip();
  inline void set_allocated_client_ip(::std::string* client_ip);

  // optional string target_ip = 4;
  inline bool has_target_ip() const;
  inline void clear_target_ip();
  static const int kTargetIpFieldNumber = 4;
  inline const ::std::string& target_ip() const;
  inline void set_target_ip(const ::std::string& value);
  inline void set_target_ip(const char* value);
  inline void set_target_ip(const char* value, size_t size);
  inline ::std::string* mutable_target_ip();
  inline ::std::string* release_target_ip();
  inline void set_allocated_target_ip(::std::string* target_ip);

  // optional uint32 target_port = 5;
  inline bool has_target_port() const;
  inline void clear_target_port();
  static const int kTargetPortFieldNumber = 5;
  inline ::google::protobuf::uint32 target_port() const;
  inline void set_target_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.Head)
 private:
  inline void set_has_session_no();
  inline void clear_has_session_no();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_target_ip();
  inline void clear_has_target_ip();
  inline void set_has_target_port();
  inline void clear_has_target_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* session_no_;
  ::std::string* client_ip_;
  ::google::protobuf::uint32 message_type_;
  ::google::protobuf::uint32 target_port_;
  ::std::string* target_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class Body : public ::google::protobuf::Message {
 public:
  Body();
  virtual ~Body();

  Body(const Body& from);

  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Body& default_instance();

  void Swap(Body* other);

  // implements Message ----------------------------------------------

  Body* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Body& from);
  void MergeFrom(const Body& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rapidmsg.SimpleResponse simple_response = 1;
  inline bool has_simple_response() const;
  inline void clear_simple_response();
  static const int kSimpleResponseFieldNumber = 1;
  inline const ::rapidmsg::SimpleResponse& simple_response() const;
  inline ::rapidmsg::SimpleResponse* mutable_simple_response();
  inline ::rapidmsg::SimpleResponse* release_simple_response();
  inline void set_allocated_simple_response(::rapidmsg::SimpleResponse* simple_response);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Body)
  // @@protoc_insertion_point(class_scope:rapidmsg.Body)
 private:
  inline void set_has_simple_response();
  inline void clear_has_simple_response();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rapidmsg::SimpleResponse* simple_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static Body* default_instance_;
};
// -------------------------------------------------------------------

class IpPortPair : public ::google::protobuf::Message {
 public:
  IpPortPair();
  virtual ~IpPortPair();

  IpPortPair(const IpPortPair& from);

  inline IpPortPair& operator=(const IpPortPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpPortPair& default_instance();

  void Swap(IpPortPair* other);

  // implements Message ----------------------------------------------

  IpPortPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpPortPair& from);
  void MergeFrom(const IpPortPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.IpPortPair)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static IpPortPair* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCode : public ::google::protobuf::Message {
 public:
  ResponseCode();
  virtual ~ResponseCode();

  ResponseCode(const ResponseCode& from);

  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCode& default_instance();

  void Swap(ResponseCode* other);

  // implements Message ----------------------------------------------

  ResponseCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:rapidmsg.ResponseCode)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_message_;
  ::google::protobuf::int32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static ResponseCode* default_instance_;
};
// -------------------------------------------------------------------

class IpAddress : public ::google::protobuf::Message {
 public:
  IpAddress();
  virtual ~IpAddress();

  IpAddress(const IpAddress& from);

  inline IpAddress& operator=(const IpAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpAddress& default_instance();

  void Swap(IpAddress* other);

  // implements Message ----------------------------------------------

  IpAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpAddress& from);
  void MergeFrom(const IpAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.IpAddress)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static IpAddress* default_instance_;
};
// -------------------------------------------------------------------

class SimpleResponse : public ::google::protobuf::Message {
 public:
  SimpleResponse();
  virtual ~SimpleResponse();

  SimpleResponse(const SimpleResponse& from);

  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleResponse& default_instance();

  void Swap(SimpleResponse* other);

  // implements Message ----------------------------------------------

  SimpleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleResponse& from);
  void MergeFrom(const SimpleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rapidmsg.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::rapidmsg::ResponseCode& rc() const;
  inline ::rapidmsg::ResponseCode* mutable_rc();
  inline ::rapidmsg::ResponseCode* release_rc();
  inline void set_allocated_rc(::rapidmsg::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:rapidmsg.SimpleResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rapidmsg::ResponseCode* rc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static SimpleResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalHead : public ::google::protobuf::Message {
 public:
  InternalHead();
  virtual ~InternalHead();

  InternalHead(const InternalHead& from);

  inline InternalHead& operator=(const InternalHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHead& default_instance();

  void Swap(InternalHead* other);

  // implements Message ----------------------------------------------

  InternalHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHead& from);
  void MergeFrom(const InternalHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fd = 10;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 10;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // required uint32 peer_addr = 20;
  inline bool has_peer_addr() const;
  inline void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 20;
  inline ::google::protobuf::uint32 peer_addr() const;
  inline void set_peer_addr(::google::protobuf::uint32 value);

  // required int32 peer_port = 30;
  inline bool has_peer_port() const;
  inline void clear_peer_port();
  static const int kPeerPortFieldNumber = 30;
  inline ::google::protobuf::int32 peer_port() const;
  inline void set_peer_port(::google::protobuf::int32 value);

  // required uint32 sock_addr = 40;
  inline bool has_sock_addr() const;
  inline void clear_sock_addr();
  static const int kSockAddrFieldNumber = 40;
  inline ::google::protobuf::uint32 sock_addr() const;
  inline void set_sock_addr(::google::protobuf::uint32 value);

  // required int32 sock_port = 50;
  inline bool has_sock_port() const;
  inline void clear_sock_port();
  static const int kSockPortFieldNumber = 50;
  inline ::google::protobuf::int32 sock_port() const;
  inline void set_sock_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rapidmsg.InternalHead)
 private:
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_peer_addr();
  inline void clear_has_peer_addr();
  inline void set_has_peer_port();
  inline void clear_has_peer_port();
  inline void set_has_sock_addr();
  inline void clear_has_sock_addr();
  inline void set_has_sock_port();
  inline void clear_has_sock_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 fd_;
  ::google::protobuf::uint32 peer_addr_;
  ::google::protobuf::int32 peer_port_;
  ::google::protobuf::uint32 sock_addr_;
  ::google::protobuf::int32 sock_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_rapidmsg_2eproto();
  friend void protobuf_AssignDesc_rapidmsg_2eproto();
  friend void protobuf_ShutdownFile_rapidmsg_2eproto();

  void InitAsDefaultInstance();
  static InternalHead* default_instance_;
};
// ===================================================================


// ===================================================================

// RMessage

// required .rapidmsg.Head head = 1;
inline bool RMessage::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RMessage::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RMessage::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RMessage::clear_head() {
  if (head_ != NULL) head_->::rapidmsg::Head::Clear();
  clear_has_head();
}
inline const ::rapidmsg::Head& RMessage::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::rapidmsg::Head* RMessage::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::rapidmsg::Head;
  return head_;
}
inline ::rapidmsg::Head* RMessage::release_head() {
  clear_has_head();
  ::rapidmsg::Head* temp = head_;
  head_ = NULL;
  return temp;
}
inline void RMessage::set_allocated_head(::rapidmsg::Head* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .rapidmsg.Body body = 2;
inline bool RMessage::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RMessage::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RMessage::clear_body() {
  if (body_ != NULL) body_->::rapidmsg::Body::Clear();
  clear_has_body();
}
inline const ::rapidmsg::Body& RMessage::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::rapidmsg::Body* RMessage::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::rapidmsg::Body;
  return body_;
}
inline ::rapidmsg::Body* RMessage::release_body() {
  clear_has_body();
  ::rapidmsg::Body* temp = body_;
  body_ = NULL;
  return temp;
}
inline void RMessage::set_allocated_body(::rapidmsg::Body* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}

// -------------------------------------------------------------------

// Head

// required string session_no = 1;
inline bool Head::has_session_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_session_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Head::clear_has_session_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Head::clear_session_no() {
  if (session_no_ != &::google::protobuf::internal::kEmptyString) {
    session_no_->clear();
  }
  clear_has_session_no();
}
inline const ::std::string& Head::session_no() const {
  return *session_no_;
}
inline void Head::set_session_no(const ::std::string& value) {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  session_no_->assign(value);
}
inline void Head::set_session_no(const char* value) {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  session_no_->assign(value);
}
inline void Head::set_session_no(const char* value, size_t size) {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  session_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_session_no() {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  return session_no_;
}
inline ::std::string* Head::release_session_no() {
  clear_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_no_;
    session_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_session_no(::std::string* session_no) {
  if (session_no_ != &::google::protobuf::internal::kEmptyString) {
    delete session_no_;
  }
  if (session_no) {
    set_has_session_no();
    session_no_ = session_no;
  } else {
    clear_has_session_no();
    session_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 message_type = 2;
inline bool Head::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Head::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Head::clear_message_type() {
  message_type_ = 0u;
  clear_has_message_type();
}
inline ::google::protobuf::uint32 Head::message_type() const {
  return message_type_;
}
inline void Head::set_message_type(::google::protobuf::uint32 value) {
  set_has_message_type();
  message_type_ = value;
}

// optional string client_ip = 3;
inline bool Head::has_client_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_client_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Head::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Head::clear_client_ip() {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    client_ip_->clear();
  }
  clear_has_client_ip();
}
inline const ::std::string& Head::client_ip() const {
  return *client_ip_;
}
inline void Head::set_client_ip(const ::std::string& value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void Head::set_client_ip(const char* value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void Head::set_client_ip(const char* value, size_t size) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  return client_ip_;
}
inline ::std::string* Head::release_client_ip() {
  clear_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_ip_;
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_client_ip(::std::string* client_ip) {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete client_ip_;
  }
  if (client_ip) {
    set_has_client_ip();
    client_ip_ = client_ip;
  } else {
    clear_has_client_ip();
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target_ip = 4;
inline bool Head::has_target_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Head::set_has_target_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Head::clear_has_target_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Head::clear_target_ip() {
  if (target_ip_ != &::google::protobuf::internal::kEmptyString) {
    target_ip_->clear();
  }
  clear_has_target_ip();
}
inline const ::std::string& Head::target_ip() const {
  return *target_ip_;
}
inline void Head::set_target_ip(const ::std::string& value) {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  target_ip_->assign(value);
}
inline void Head::set_target_ip(const char* value) {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  target_ip_->assign(value);
}
inline void Head::set_target_ip(const char* value, size_t size) {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  target_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_target_ip() {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  return target_ip_;
}
inline ::std::string* Head::release_target_ip() {
  clear_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_ip_;
    target_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_target_ip(::std::string* target_ip) {
  if (target_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete target_ip_;
  }
  if (target_ip) {
    set_has_target_ip();
    target_ip_ = target_ip;
  } else {
    clear_has_target_ip();
    target_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 target_port = 5;
inline bool Head::has_target_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Head::set_has_target_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Head::clear_has_target_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Head::clear_target_port() {
  target_port_ = 0u;
  clear_has_target_port();
}
inline ::google::protobuf::uint32 Head::target_port() const {
  return target_port_;
}
inline void Head::set_target_port(::google::protobuf::uint32 value) {
  set_has_target_port();
  target_port_ = value;
}

// -------------------------------------------------------------------

// Body

// optional .rapidmsg.SimpleResponse simple_response = 1;
inline bool Body::has_simple_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Body::set_has_simple_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Body::clear_has_simple_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Body::clear_simple_response() {
  if (simple_response_ != NULL) simple_response_->::rapidmsg::SimpleResponse::Clear();
  clear_has_simple_response();
}
inline const ::rapidmsg::SimpleResponse& Body::simple_response() const {
  return simple_response_ != NULL ? *simple_response_ : *default_instance_->simple_response_;
}
inline ::rapidmsg::SimpleResponse* Body::mutable_simple_response() {
  set_has_simple_response();
  if (simple_response_ == NULL) simple_response_ = new ::rapidmsg::SimpleResponse;
  return simple_response_;
}
inline ::rapidmsg::SimpleResponse* Body::release_simple_response() {
  clear_has_simple_response();
  ::rapidmsg::SimpleResponse* temp = simple_response_;
  simple_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_simple_response(::rapidmsg::SimpleResponse* simple_response) {
  delete simple_response_;
  simple_response_ = simple_response;
  if (simple_response) {
    set_has_simple_response();
  } else {
    clear_has_simple_response();
  }
}

// -------------------------------------------------------------------

// IpPortPair

// required uint32 ip = 1;
inline bool IpPortPair::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpPortPair::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpPortPair::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpPortPair::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 IpPortPair::ip() const {
  return ip_;
}
inline void IpPortPair::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required uint32 port = 2;
inline bool IpPortPair::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpPortPair::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpPortPair::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpPortPair::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpPortPair::port() const {
  return port_;
}
inline void IpPortPair::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ResponseCode

// required int32 retcode = 1;
inline bool ResponseCode::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCode::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCode::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 ResponseCode::retcode() const {
  return retcode_;
}
inline void ResponseCode::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string error_message = 2;
inline bool ResponseCode::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCode::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCode::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCode::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& ResponseCode::error_message() const {
  return *error_message_;
}
inline void ResponseCode::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ResponseCode::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ResponseCode::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseCode::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* ResponseCode::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseCode::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IpAddress

// required string ip = 1;
inline bool IpAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddress::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& IpAddress::ip() const {
  return *ip_;
}
inline void IpAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void IpAddress::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void IpAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IpAddress::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* IpAddress::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IpAddress::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 type = 2;
inline bool IpAddress::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddress::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddress::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddress::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 IpAddress::type() const {
  return type_;
}
inline void IpAddress::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SimpleResponse

// required .rapidmsg.ResponseCode rc = 1;
inline bool SimpleResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleResponse::clear_rc() {
  if (rc_ != NULL) rc_->::rapidmsg::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::rapidmsg::ResponseCode& SimpleResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::rapidmsg::ResponseCode* SimpleResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::rapidmsg::ResponseCode;
  return rc_;
}
inline ::rapidmsg::ResponseCode* SimpleResponse::release_rc() {
  clear_has_rc();
  ::rapidmsg::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void SimpleResponse::set_allocated_rc(::rapidmsg::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// -------------------------------------------------------------------

// InternalHead

// required int32 fd = 10;
inline bool InternalHead::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHead::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHead::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHead::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 InternalHead::fd() const {
  return fd_;
}
inline void InternalHead::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// required uint32 peer_addr = 20;
inline bool InternalHead::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalHead::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalHead::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalHead::clear_peer_addr() {
  peer_addr_ = 0u;
  clear_has_peer_addr();
}
inline ::google::protobuf::uint32 InternalHead::peer_addr() const {
  return peer_addr_;
}
inline void InternalHead::set_peer_addr(::google::protobuf::uint32 value) {
  set_has_peer_addr();
  peer_addr_ = value;
}

// required int32 peer_port = 30;
inline bool InternalHead::has_peer_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalHead::set_has_peer_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalHead::clear_has_peer_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalHead::clear_peer_port() {
  peer_port_ = 0;
  clear_has_peer_port();
}
inline ::google::protobuf::int32 InternalHead::peer_port() const {
  return peer_port_;
}
inline void InternalHead::set_peer_port(::google::protobuf::int32 value) {
  set_has_peer_port();
  peer_port_ = value;
}

// required uint32 sock_addr = 40;
inline bool InternalHead::has_sock_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalHead::set_has_sock_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalHead::clear_has_sock_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalHead::clear_sock_addr() {
  sock_addr_ = 0u;
  clear_has_sock_addr();
}
inline ::google::protobuf::uint32 InternalHead::sock_addr() const {
  return sock_addr_;
}
inline void InternalHead::set_sock_addr(::google::protobuf::uint32 value) {
  set_has_sock_addr();
  sock_addr_ = value;
}

// required int32 sock_port = 50;
inline bool InternalHead::has_sock_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalHead::set_has_sock_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalHead::clear_has_sock_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalHead::clear_sock_port() {
  sock_port_ = 0;
  clear_has_sock_port();
}
inline ::google::protobuf::int32 InternalHead::sock_port() const {
  return sock_port_;
}
inline void InternalHead::set_sock_port(::google::protobuf::int32 value) {
  set_has_sock_port();
  sock_port_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rapidmsg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rapidmsg::MessageType>() {
  return ::rapidmsg::MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rapidmsg_2eproto__INCLUDED
